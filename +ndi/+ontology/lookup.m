% Location: +ndi/+ontology/lookup.m
% Revised to use 'which' for validating function existence

function [id, name, prefix, definition, synonyms] = lookup(lookupString)
% LOOKUP - Look up a term in an ontology using a specific identifier or term.
%
%   [ID, NAME, PREFIX, DEFINITION, SYNONYMS] = ndi.ontology.lookup(LOOKUPSTRING)
%
%   Looks up a term in a known ontology using a lookup string that specifies
%   both the ontology and the term/identifier within that ontology.
%
%   LOOKUPSTRING should have an ontology prefix followed by a colon (:) and
%   then the specific identifier or term name to look up within that ontology.
%   Example: 'NCBITaxon:9606', 'Uberon:anatomical entity', 'CL:0000000', 'OM:metre'
%
%   The function first identifies the ontology based on the prefix using
%   ndi.ontology.getOntologyNameFromPrefix. It then calls a corresponding
%   ontology-specific function named 'ndi.ontology.lookup_ONTOLOGYNAME',
%   (e.g., ndi.ontology.lookup_NCBITaxon) passing the identifier/term part
%   of the LOOKUPSTRING to that function.
%
%   LOOKUP retrieves exact matches based on the provided identifier or term.
%   It does not search for close matches. Use ndi.ontology.search for that purpose.
%
%   Outputs:
%     ID           - The canonical identifier for the term in the ontology (char).
%     NAME         - The primary name or label for the term (char).
%     PREFIX       - The ontology prefix used in the lookup (char).
%     DEFINITION   - A textual definition of the term, if available (char). Empty ('') if not.
%     SYNONYMS     - A cell array of character vectors listing synonyms, if available. Empty cell ({}) if not.
%
%   Error Conditions:
%     - Throws an error if LOOKUPSTRING is empty, not text, or not convertible to char.
%     - Throws an error if the prefix in LOOKUPSTRING cannot be mapped to a known ontology
%       via the JSON mapping file used by getOntologyNameFromPrefix.
%     - Throws an error if LOOKUPSTRING does not contain a colon ':' separating the
%       prefix and the identifier/term (unless handled specifically by lookup_X).
%     - Throws an error if the corresponding 'ndi.ontology.lookup_ONTOLOGYNAME'
%       function does not exist on the MATLAB path (checked using 'which').
%     - May rethrow errors generated by the specific lookup function if the term/ID
%       is not found within that ontology or if other issues occur during the lookup.
%
%   See also: ndi.ontology.search, ndi.ontology.getOntologyNameFromPrefix

arguments
    % Input string containing prefix:identifier or prefix:term
    lookupString (1,:) char {mustBeNonempty}
end

% Initialize outputs to default empty values
id = '';
name = '';
prefix = '';
definition = '';
synonyms = {}; % Empty cell array for synonyms

% --- Step 1: Determine Ontology Name and Remainder (Term/ID) ---
% This call also implicitly validates the prefix exists in the mapping JSON
try
    [ontologyName, remainder] = ndi.ontology.getOntologyNameFromPrefix(lookupString);
    % If getOntologyNameFromPrefix succeeds but returns empty ontologyName
    % (which shouldn't happen with current implementation if prefix matched),
    % handle it as a failure.
    if isempty(ontologyName)
        error('ndi:ontology:lookup:PrefixMappingFailed', ...
              'Failed to map prefix from "%s" to a known ontology name.', lookupString);
    end
catch ME
    % Re-throw errors from getOntologyNameFromPrefix (e.g., prefix not found in JSON)
    fprintf('Error occurred during prefix mapping for "%s".\n', lookupString);
    rethrow(ME);
end

% --- Step 2: Validate Input Format and Extract Prefix ---
% We need the prefix for the output. getOntologyNameFromPrefix doesn't return it.
colonPos = strfind(lookupString, ':');
if isempty(colonPos)
     % This case should ideally be handled by getOntologyNameFromPrefix or
     % the specific lookup function might handle prefix-only inputs if designed to.
     % For now, assume standard format is required by most lookup_X funcs called here.
     warning('ndi:ontology:lookup:MissingColon', ...
             'Input string "%s" lacks a colon separator. Behavior depends on the specific lookup function for ontology "%s".', ...
             lookupString, ontologyName);
     prefix = lookupString; % Treat whole string as prefix? Or error? Let's assume prefix is the whole string here.
     remainder = ''; % Remainder is empty if no colon
else
    firstColonPos = colonPos(1);
    prefix = strtrim(lookupString(1:firstColonPos-1));
    % Remainder is already extracted by getOntologyNameFromPrefix
end

% Some lookup functions require a non-empty remainder
% Let's add a check here, though individual functions might handle it.
% if isempty(remainder)
%     error('ndi:ontology:lookup:MissingIdentifier',...
%           'Input "%s" requires an identifier or term after the colon for ontology "%s".', ...
%           lookupString, ontologyName);
% end


% --- Step 3: Construct and Validate Specific Lookup Function Name ---
specificFunctionName = ['ndi.ontology.lookup_' ontologyName];

% *** Use 'which' to check if the specific function exists on the path ***
functionPath = which(specificFunctionName);

if isempty(functionPath)
    % Throw error if 'which' returns empty (function not found on path)
    error('ndi:ontology:lookup:MissingSpecificFunction', ...
          'Required ontology-specific lookup function "%s" not found on the MATLAB path. Searched using ''which''.', specificFunctionName);
end
% *** End of change ***

% --- Step 4: Call the Specific Lookup Function ---
try
    % Convert function name string to a function handle
    funcHandle = str2func(specificFunctionName);

    % Call the specific function. Assume its signature is:
    % [id_out, name_out, def_out, syn_out] = specific_lookup_function(remainder_string)
    % It should return the details based on the 'remainder'.
    % NOTE: The specific lookup functions now handle ID vs Name internally.
    [id_out, name_out, def_out, syn_out] = funcHandle(remainder);

    % --- Step 5: Assign Outputs ---
    % Assign results from specific function, ensuring char/cell types
    id = char(id_out);
    name = char(name_out);
    % prefix is already assigned from Step 2
    definition = char(def_out);

    % Handle synonyms - ensure it's a cell array of chars
    if isempty(syn_out)
        synonyms = {};
    elseif ischar(syn_out) % If specific function returns single char synonym
        synonyms = {syn_out};
    elseif isstring(syn_out) % If specific function returns string array/scalar
        synonyms = cellstr(syn_out);
    elseif iscell(syn_out) % If already a cell, ensure contents are char
        synonyms = cellfun(@char, syn_out, 'UniformOutput', false);
         % Filter empty cells that might result from char conversion
        synonyms = synonyms(~cellfun('isempty', synonyms));
        if isempty(synonyms)
            synonyms = {}; % Ensure it's {} and not 1x0 cell
        end
    else
        warning('ndi:ontology:lookup:UnexpectedSynonymType', ...
                'Unexpected data type received for synonyms from %s. Returning empty.', specificFunctionName);
        synonyms = {};
    end

catch ME
    % Catch errors specifically from the str2func/function handle call
    fprintf('Error occurred during call to specific lookup function: %s\n', specificFunctionName);
    fprintf('Input remainder passed to %s: "%s"\n', specificFunctionName, remainder);

    % Add context to the error or rethrow
    if strcmp(ME.identifier, 'MATLAB:UndefinedFunction')
         % This might happen if 'which' found something but str2func failed
         baseME = MException('ndi:ontology:lookup:SpecificFunctionCallError', ...
               'Attempted to call "%s", but it failed (might not be a valid function).', specificFunctionName);
         baseME = addCause(baseME, ME);
         throw(baseME);
    else
        % Rethrow the error that originated from the specific lookup function
        % (e.g., term not found within that ontology, API error)
        fprintf('Rethrowing error from %s.\n', specificFunctionName);
        rethrow(ME);
    end
end

end % function

